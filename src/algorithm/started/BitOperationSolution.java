package algorithm.started;

public class BitOperationSolution {

    /**
     * 231
     * 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。
     * 如果存在一个整数 x 使得n == 2x ，则认为 n 是 2 的幂次方。
     *
     * 示例 1：
     * 输入：n = 1
     * 输出：true
     * 解释：20 = 1
     * 示例 2：
     * 输入：n = 16
     * 输出：true
     * 解释：24 = 16
     * 示例 3：
     * 输入：n = 3
     * 输出：false
     * 示例 4：
     * 输入：n = 4
     * 输出：true
     * 示例 5：
     * 输入：n = 5
     * 输出：false
     *
     * 提示：
     * -231 <= n <= 231 - 1
     *
     * 进阶：你能够不使用循环/递归解决此问题吗？
     */
    public static boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }

    /**
     * 191
     *
     * 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
     *
     * 提示：
     * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
     * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的示例 3中，输入表示有符号整数 -3。
     *
     * 示例 1：
     * 输入：00000000000000000000000000001011
     * 输出：3
     * 解释：输入的二进制串 00000000000000000000000000001011中，共有三位为 '1'。
     * 示例 2：
     * 输入：00000000000000000000000010000000
     * 输出：1
     * 解释：输入的二进制串 00000000000000000000000010000000中，共有一位为 '1'。
     * 示例 3：
     * 输入：11111111111111111111111111111101
     * 输出：31
     * 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
     *
     * 提示：
     * 输入必须是长度为 32 的 二进制串 。
     * 进阶：
     * 如果多次调用这个函数，你将如何优化你的算法？
     */
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
//        int res = 0;
//        int num = 1;
//        for (int i = 0; i < 32; i++) {
//            if ((n & num) == num) {
//                res++;
//            }
//            num *= 2;
//        }
//        return res;

        int ret = 0;
        while (n != 0) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }

    /**
     * 190
     * 颠倒给定的 32 位无符号整数的二进制位。
     *
     * 提示：
     * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
     * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
     *
     * 示例 1：
     * 输入：n = 00000010100101000001111010011100
     * 输出：964176192 (00111001011110000010100101000000)
     * 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     * 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
     * 示例 2：
     * 输入：n = 11111111111111111111111111111101
     * 输出：3221225471 (10111111111111111111111111111111)
     * 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     * 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
     *
     * 提示：
     * 输入是一个长度为 32 的二进制字符串
     *
     * 进阶: 如果多次调用这个函数，你将如何优化你的算法？
     */
    // you need treat n as an unsigned value
    public static int reverseBits(int n) {
//        int res = 0;
//        int num = 1;
//        for (int i = 1; i < 33; i++) {
//            if ((n & num) == num) {
//                res += 1 << (32 - i);
//            }
//            num *= 2;
//        }
//        return res;

        int rev = 0;
        for (int i = 0; i < 32 && n != 0; ++i) {
            rev |= (n & 1) << (31 - i);
            n >>>= 1;
        }
        return rev;
    }

    /**
     * 136
     * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
     *
     * 说明：
     * 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
     *
     * 示例 1:
     * 输入: [2,2,1]
     * 输出: 1
     * 示例2:
     * 输入: [4,1,2,1,2]
     * 输出: 4
     */
    public static int singleNumber(int[] nums) {
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res ^= nums[i];
        }
        return res;
    }

    public static void main(String[] args) {
        int[] nums = new int[] {2, 1, 2};
        System.out.println(singleNumber(nums));
    }
}
